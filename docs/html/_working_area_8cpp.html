<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sandsara: firmwareSandsara/src/WorkingArea.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo 50x50.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sandsara
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_working_area_8cpp.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">WorkingArea.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="_working_area_8h_source.html">WorkingArea.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6e55dcd0d80f36ea170e78f08d0cfd6c"><td class="memItemLeft" align="right" valign="top">MeanFilter&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a6e55dcd0d80f36ea170e78f08d0cfd6c">meanFilter</a> (5)</td></tr>
<tr class="separator:a6e55dcd0d80f36ea170e78f08d0cfd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36f626dfaa322b0676e3a69cd45d899"><td class="memItemLeft" align="right" valign="top">MeanFilter&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#af36f626dfaa322b0676e3a69cd45d899">meanFilter2</a> (40)</td></tr>
<tr class="separator:af36f626dfaa322b0676e3a69cd45d899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda57768904b6418e308a0eba529f3c2"><td class="memItemLeft" align="right" valign="top">MeanFilter&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#afda57768904b6418e308a0eba529f3c2">meanFilter3</a> (10)</td></tr>
<tr class="separator:afda57768904b6418e308a0eba529f3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82191621fe6f3c65317038ee5e1b9ef5"><td class="memItemLeft" align="right" valign="top">MeanFilter&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a82191621fe6f3c65317038ee5e1b9ef5">meanFilter4</a> (10)</td></tr>
<tr class="separator:a82191621fe6f3c65317038ee5e1b9ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798bb0d6da779177b10015a9174f4057"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a798bb0d6da779177b10015a9174f4057">findingSlowSensor2</a> ()</td></tr>
<tr class="memdesc:a798bb0d6da779177b10015a9174f4057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta funcion continua con el proceso de calibracion una vez que el brazo 2 esta cerca del sensor hall. DESCRIPCION GENERAL Inicia moviendose 100 pasos en sentido antihorario Regresa en sentido horario hasta que es detectado por el sensor Continua moviendose en sentido horario hasta completar 600 pasos, en cada paso toma la medicion del sensor y este dato se almacena en el vector value2_r[] Regresa el brazo en sentido antihorario hasta que es detectado por el sensor Continua moviendose en sentido antihorario hasta completar 600 pasos, en cada paso toma la medicion del sensor y este dato se almacena en el vector value2[] La grafica de ambos vectores es de forma gaussiana por lo cual se determina un limite del rango de busqueda en ambas funciones, dicho rango se establecio como los valores mayores al 90% del valor maximo encontrado. Se determinan los pasos correspondientes a el limite derecho y el limite izquierdo de ambas funciones y se usa el limite derecho de la funcion dos y el limite izquierdo de la funcion uno para encontrar el punto medio. Se calculan los pasos necesarios para llegar al punto medio del sensor.  <a href="#a798bb0d6da779177b10015a9174f4057">More...</a><br /></td></tr>
<tr class="separator:a798bb0d6da779177b10015a9174f4057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bc9fa321501271396177a33c87ad83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a66bc9fa321501271396177a33c87ad83">findingSlowSensor1</a> ()</td></tr>
<tr class="memdesc:a66bc9fa321501271396177a33c87ad83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta funcion continua con el proceso de calibracion una vez que el brazo 1 esta cerca del sensor hall.  <a href="#a66bc9fa321501271396177a33c87ad83">More...</a><br /></td></tr>
<tr class="separator:a66bc9fa321501271396177a33c87ad83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb69637e5b2f4d22887510391cb973d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a4cb69637e5b2f4d22887510391cb973d">findingSlowSensor2Negative</a> ()</td></tr>
<tr class="memdesc:a4cb69637e5b2f4d22887510391cb973d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta funcion continua con el proceso de calibracion una vez que el brazo 2 esta cerca del sensor hall, esta version de la funcion contempla el polo negativo del iman DESCRIPCION GENERAL Inicia moviendose 100 pasos en sentido antihorario Regresa en sentido horario hasta que es detectado por el sensor Continua moviendose en sentido horario hasta completar 600 pasos, en cada paso toma la medicion del sensor y este dato se almacena en el vector value2_r[] Regresa el brazo en sentido antihorario hasta que es detectado por el sensor Continua moviendose en sentido antihorario hasta completar 600 pasos, en cada paso toma la medicion del sensor y este dato se almacena en el vector value2[] La grafica de ambos vectores es de forma gaussiana por lo cual se determina un limite del rango de busqueda en ambas funciones, dicho rango se establecio como los valores mayores al 90% del valor maximo encontrado. Se determinan los pasos correspondientes a el limite derecho y el limite izquierdo de ambas funciones y se usa el limite derecho de la funcion dos y el limite izquierdo de la funcion uno para encontrar el punto medio. Se calculan los pasos necesarios para llegar al punto medio del sensor.  <a href="#a4cb69637e5b2f4d22887510391cb973d">More...</a><br /></td></tr>
<tr class="separator:a4cb69637e5b2f4d22887510391cb973d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ff294cb56b4ed4e7a7fbbc7b09e378"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#af6ff294cb56b4ed4e7a7fbbc7b09e378">findingSlowSensor1Negative</a> ()</td></tr>
<tr class="memdesc:af6ff294cb56b4ed4e7a7fbbc7b09e378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta funcion continua con el proceso de calibracion una vez que el brazo 1 esta cerca del sensor hall, esta version de la funcion contempla el polo negativo del iman DESCRIPCION GENERAL Inicia moviendo el brazo uno 80 pasos en sentido antihorario para salir por completo del rango del sensor Comienza a tomar mediciones del sensor en cada paso que avanza en sentido horario hasta llenar el vector value[] Durante el llenado del vector tambien se determina el valor maximo entre todos los elementos del vector La grafica de los datos tiene forma gaussiana por lo cual se determina un limite del rango en cual se buscara el punto medio de la funcion, dicho rango se establecio como los valores mayores al 90% del valor maximo encontrado. Se determinan los pasos correspondientes a el limite derecho y el limite izquierdo de la funcion Se calculan los pasos necesarios para llegar al punto medio del sensor.  <a href="#af6ff294cb56b4ed4e7a7fbbc7b09e378">More...</a><br /></td></tr>
<tr class="separator:af6ff294cb56b4ed4e7a7fbbc7b09e378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff22892fe13e126f6290b4986ab47b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a3ff22892fe13e126f6290b4986ab47b8">configTimerForMovement</a> ()</td></tr>
<tr class="separator:a3ff22892fe13e126f6290b4986ab47b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b0be76d13262e07d312e41bba6ab02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a66b0be76d13262e07d312e41bba6ab02">move</a> (int pasos, int motor_d, int <a class="el" href="_working_area_8cpp.html#a04caa6dcdf90645ea95e5f3281d780cd">Speed</a>)</td></tr>
<tr class="memdesc:a66b0be76d13262e07d312e41bba6ab02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta funcion perimite mover los motores de manera controlada mediante numero de pasos.  <a href="#a66b0be76d13262e07d312e41bba6ab02">More...</a><br /></td></tr>
<tr class="separator:a66b0be76d13262e07d312e41bba6ab02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84621fca61c95f2748a53815d2a856fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a84621fca61c95f2748a53815d2a856fb">zero_Hall1</a> (void)</td></tr>
<tr class="memdesc:a84621fca61c95f2748a53815d2a856fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta funcion determina el nivel de referencia a partir del cual se considera la deteccion de campo magnetico. DESCRIPCION GENERAL Esta funcion inicia moviendo el brazo en sentido antihorario usando la funcion configTimerForMovement y sensando el DIAG_PIN en caso de que el brazo colisione, si colisiona el brazo 1 regresa 300 pasos y el brazo 2 baja a 90 grados para evitar la colision. Si el brazo logra finalizar el primer movimiento sin colisionar regresa 800 pasos e inicia el algoritmo para determinar el nivel cero del sensor. Se toman 5 muestras en angulos distintos, la primera muestra se toma desde donde quedo posicionado el brazo, posteriormente se mueve 10 grados en sentido horario para tomar la segunda muestra, se mueve 10 grados en sentido horario para la tercera medicion, regresa 30 grados en sentido antihorario para la cuarta medicion y avanza 10 grados mas para tomar la quita medicion. En cada una de las 5 muestras se toman 5 mediciones filtradas de las cuales se obtienen el valor maximo, el valor minimo, el valor promedio y un valor al que se le determino como valor similitud ya que es comparado con cada promedio de las 5 muestras tomadas a diferentes algulos y se almacena el contador de cuantos valores son similares al de la muestra analizada. Finalmente se determina que si 3 muestras o mas son similares se ha hallado el valor cero del sensor el cual se almacena en una variable global y se retorna un 1 para indicar que no es necesario repetir el procedimiento.  <a href="#a84621fca61c95f2748a53815d2a856fb">More...</a><br /></td></tr>
<tr class="separator:a84621fca61c95f2748a53815d2a856fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83423ebb090b867ca0e0680ba5ee33ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a83423ebb090b867ca0e0680ba5ee33ef">zero_Hall2</a> (void)</td></tr>
<tr class="memdesc:a83423ebb090b867ca0e0680ba5ee33ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta funcion determina el nivel de referencia a partir del cual se considera la deteccion de campo magnetico. DESCRIPCION GENERAL Esta funcion inicia moviendo el brazo en sentido antihorario usando la funcion configTimerForMovement y sensando el DIAG_PIN en caso de que el brazo colisione, si colisiona el brazo 1 regresa 300 pasos y el brazo 2 baja a 90 grados para evitar la colision. Si el brazo logra finalizar el primer movimiento sin colisionar regresa 800 pasos e inicia el algoritmo para determinar el nivel cero del sensor. Se toman 5 muestras en angulos distintos, la primera muestra se toma desde donde quedo posicionado el brazo, posteriormente se mueve 10 grados en sentido horario para tomar la segunda muestra, se mueve 10 grados en sentido horario para la tercera medicion, regresa 30 grados en sentido antihorario para la cuarta medicion y avanza 10 grados mas para tomar la quita medicion. En cada una de las 5 muestras se toman 5 mediciones filtradas de las cuales se obtienen el valor maximo, el valor minimo, el valor promedio y un valor al que se le determino como valor similitud ya que es comparado con cada promedio de las 5 muestras tomadas a diferentes algulos y se almacena el contador de cuantos valores son similares al de la muestra analizada. Finalmente se determina que si 3 muestras o mas son similares se ha hallado el valor cero del sensor el cual se almacena en una variable global y se retorna un 1 para indicar que no es necesario repetir el procedimiento.  <a href="#a83423ebb090b867ca0e0680ba5ee33ef">More...</a><br /></td></tr>
<tr class="separator:a83423ebb090b867ca0e0680ba5ee33ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ecbafdb3302781652a880f1abbfc0e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#ab5ecbafdb3302781652a880f1abbfc0e">Pole1</a> (void)</td></tr>
<tr class="memdesc:ab5ecbafdb3302781652a880f1abbfc0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta funcion determina el polo del campo magnetico correspondiente al iman que interacciona con el brazo 1. DESCRIPCION GFENERAL Antes de entrar a esta funcion el brazo ya se encuentra posicionado correctamente al inicio del sensor Para determinar el polo se avanzan 100 pasos para que al retornar el movimiento el brazo termine en la mis ma posicion en la que inicio. Al retornar el sentido horario almacena el valor maximo y el valor minimo que haya obtenidode las mediciones tomadas en cada paso, este valor se obtiene como un valor absoluto respecto del nivel cero, el cual para este punto del programa ya se conoce. finalmente se compara el valor maximo absoluto obtenido y el valor minimo absoluto obtenido, si el maximo absoluto es mayor que el minimo absoluto se determina que le polo es positivo, en cambio si sucede de forma contraria se determina que el polo es negativo.  <a href="#ab5ecbafdb3302781652a880f1abbfc0e">More...</a><br /></td></tr>
<tr class="separator:ab5ecbafdb3302781652a880f1abbfc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad469423184c79fb13fe91abe154193f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#ad469423184c79fb13fe91abe154193f9">Pole2</a> (void)</td></tr>
<tr class="memdesc:ad469423184c79fb13fe91abe154193f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta funcion determina el polo del campo magnetico correspondiente al iman que interacciona con el brazo 2. DESCRIPCION GFENERAL Antes de entrar a esta funcion el brazo ya se encuentra posicionado correctamente al inicio del sensor Para determinar el polo se avanzan 800 pasos para que al retornar el movimiento el brazo termine en la mis ma posicion en la que inicio. Al retornar el sentido horario almacena el valor maximo y el valor minimo que haya obtenidode las mediciones tomadas en cada paso, este valor se obtiene como un valor absoluto respecto del nivel cero, el cual para este punto del programa ya se conoce. finalmente se compara el valor maximo absoluto obtenido y el valor minimo absoluto obtenido, si el maximo absoluto es mayor que el minimo absoluto se determina que le polo es positivo, en cambio si sucede de forma contraria se determina que el polo es negativo.  <a href="#ad469423184c79fb13fe91abe154193f9">More...</a><br /></td></tr>
<tr class="separator:ad469423184c79fb13fe91abe154193f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631addbae85416e5e774ee3a4c3fb96f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a631addbae85416e5e774ee3a4c3fb96f">Check_ini</a> (void)</td></tr>
<tr class="memdesc:a631addbae85416e5e774ee3a4c3fb96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta funcion verifica si ya se han almacenado en la EEPROM las variables iniciales necesarias para en funcionamiento del sistema, lo cual solo es posible cuando se programa por primera vez la ESP32 o despues de un reset completo del sistema.  <a href="#a631addbae85416e5e774ee3a4c3fb96f">More...</a><br /></td></tr>
<tr class="separator:a631addbae85416e5e774ee3a4c3fb96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada06ab1c4bbd307a9fea75726c8894f1"><td class="memItemLeft" align="right" valign="top">void IRAM_ATTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#ada06ab1c4bbd307a9fea75726c8894f1">onTimer</a> ()</td></tr>
<tr class="separator:ada06ab1c4bbd307a9fea75726c8894f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116938c1ae9fcce8a77d45b4a1f5f31b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a116938c1ae9fcce8a77d45b4a1f5f31b">verif_cal_positiveb1</a> (void)</td></tr>
<tr class="memdesc:a116938c1ae9fcce8a77d45b4a1f5f31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta funcion se utiliza entre programas para verificar que la siguiente secuencia iniciara en el punto cero. en este caso la funcion contempla solo al brazo 1 con la polaridad del iman positiva. DESCRIPCION GENERAL En la primera condicion de esta funcion se determina si el brazo se encuentra fuera del rango del sensor En caso de entrar en esta condicion inicia una busqueda con rango maximo de 200 pasos en sentido horario Si no se encuentra nada en ese rango inicia una busqueda en sentido antihorario con un rango maximo de 400 pasos Si encuentra el sensor en la primera busqueda se activa una bandera para determinar que esta posicionado del lado izquierdo del sensor posteriormente se mueve 100 pasos en sentido horario y regresa en sentido antihorario para posicionarse al inicio del sensor pero del lado derecho. Existe otro caso en el cual al iniciar la funcion el brazo ya se encuentra dentro del rango del sensor, en ese caso se mueve 100 pasos en sentido horario para garantizar que sale del sensor y posteriormente regresa en sentido antihorario hasta que es detectado por el sensor posicionandose asi del lado derecho del sensor. Finalmente cuando ya esta posicionado al inicio del lado derecho del sensor realiza el proceso de slow calibration para centrarse correctamente.  <a href="#a116938c1ae9fcce8a77d45b4a1f5f31b">More...</a><br /></td></tr>
<tr class="separator:a116938c1ae9fcce8a77d45b4a1f5f31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6974d83fb1a8c1abd074a6003a966b17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a6974d83fb1a8c1abd074a6003a966b17">verif_cal_positiveb2</a> (void)</td></tr>
<tr class="memdesc:a6974d83fb1a8c1abd074a6003a966b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta funcion se utiliza entre programas para verificar que la siguiente secuencia iniciara en el punto cero. en este caso la funcion contempla solo al brazo 2 con la polaridad del iman positiva. DESCRIPCION GENERAL En la primera condicion de esta funcion se determina si el brazo se encuentra fuera del rango del sensor En caso de entrar en esta condicion inicia una busqueda con rango maximo de 600 pasos en sentido antihorario Si no se encuentra nada en ese rango inicia una busqueda en sentido horario con un rango maximo de 1200 pasos Si encuentra el sensor en la primera busqueda se activa una bandera para determinar que esta posicionado del lado derecho del sensor posteriormente se mueve 600 pasos en sentido antihorario y regresa en sentido horario para posicionarse al inicio del sensor pero del lado izquierdo. Existe otro caso en el cual al iniciar la funcion el brazo ya se encuentra dentro del rango del sensor, en ese caso se mueve 600 pasos en sentido antihorario para garantizar que sale del sensor y posteriormente regresa en sentido horario hasta que es detectado por el sensor posicionandose asi del lado izquierdo del sensor. Finalmente cuando ya esta posicionado al inicio del lado izquierdo del sensor realiza el proceso de slow calibration para centrarse correctamente.  <a href="#a6974d83fb1a8c1abd074a6003a966b17">More...</a><br /></td></tr>
<tr class="separator:a6974d83fb1a8c1abd074a6003a966b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aeeb796a7fc547a875cd99077220f83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a2aeeb796a7fc547a875cd99077220f83">verif_cal_negativeb1</a> (void)</td></tr>
<tr class="memdesc:a2aeeb796a7fc547a875cd99077220f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta funcion se utiliza entre programas para verificar que la siguiente secuencia iniciara en el punto cero. en este caso la funcion contempla solo al brazo 1 con la polaridad del iman negativa. DESCRIPCION GENERAL En la primera condicion de esta funcion se determina si el brazo se encuentra fuera del rango del sensor En caso de entrar en esta condicion inicia una busqueda con rango maximo de 200 pasos en sentido horario Si no se encuentra nada en ese rango inicia una busqueda en sentido antihorario con un rango maximo de 400 pasos Si encuentra el sensor en la primera busqueda se activa una bandera para determinar que esta posicionado del lado izquierdo del sensor posteriormente se mueve 100 pasos en sentido horario y regresa en sentido antihorario para posicionarse al inicio del sensor pero del lado derecho. Existe otro caso en el cual al iniciar la funcion el brazo ya se encuentra dentro del rango del sensor, en ese caso se mueve 100 pasos en sentido horario para garantizar que sale del sensor y posteriormente regresa en sentido antihorario hasta que es detectado por el sensor posicionandose asi del lado derecho del sensor. Finalmente cuando ya esta posicionado al inicio del lado izquierdo del sensor realiza el proceso de slow calibration para centrarse correctamente.  <a href="#a2aeeb796a7fc547a875cd99077220f83">More...</a><br /></td></tr>
<tr class="separator:a2aeeb796a7fc547a875cd99077220f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2348b9d8a271b99689a97fab8a460a6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a2348b9d8a271b99689a97fab8a460a6f">verif_cal_negativeb2</a> (void)</td></tr>
<tr class="memdesc:a2348b9d8a271b99689a97fab8a460a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta funcion se utiliza entre programas para verificar que la siguiente secuencia iniciara en el punto cero. en este caso la funcion contempla solo al brazo 2 con la polaridad del iman negativa. DESCRIPCION GENERAL En la primera condicion de esta funcion se determina si el brazo se encuentra fuera del rango del sensor En caso de entrar en esta condicion inicia una busqueda con rango maximo de 600 pasos en sentido antihorario Si no se encuentra nada en ese rango inicia una busqueda en sentido horario con un rango maximo de 1200 pasos Si encuentra el sensor en la primera busqueda se activa una bandera para determinar que esta posicionado del lado derecho del sensor posteriormente se mueve 600 pasos en sentido antihorario y regresa en sentido horario para posicionarse al inicio del sensor pero del lado izquierdo. Existe otro caso en el cual al iniciar la funcion el brazo ya se encuentra dentro del rango del sensor, en ese caso se mueve 600 pasos en sentido antihorario para garantizar que sale del sensor y posteriormente regresa en sentido horario hasta que es detectado por el sensor posicionandose asi del lado izquierdo del sensor. Finalmente cuando ya esta posicionado al inicio del lado izquierdo del sensor realiza el proceso de slow calibration para centrarse correctamente.  <a href="#a2348b9d8a271b99689a97fab8a460a6f">More...</a><br /></td></tr>
<tr class="separator:a2348b9d8a271b99689a97fab8a460a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8fa11698cbe6b645e4e5763adde2b20e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a8fa11698cbe6b645e4e5763adde2b20e">MICROSTEPPING</a> = String(String(<a class="el" href="main_8cpp.html#a19f09ab8a4c025b852ae0ac4f32821cd">dataS</a>[1]) + String(<a class="el" href="main_8cpp.html#a19f09ab8a4c025b852ae0ac4f32821cd">dataS</a>[2])).toFloat()</td></tr>
<tr class="separator:a8fa11698cbe6b645e4e5763adde2b20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff17ae1975ccaad350d7ce45584b8765"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#aff17ae1975ccaad350d7ce45584b8765">L</a></td></tr>
<tr class="separator:aff17ae1975ccaad350d7ce45584b8765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae925ac80771845fdf6ceecea82d43372"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#ae925ac80771845fdf6ceecea82d43372">H</a></td></tr>
<tr class="separator:ae925ac80771845fdf6ceecea82d43372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf916204820072417ed73a32de1cefcf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#adf916204820072417ed73a32de1cefcf">flag</a> = 0</td></tr>
<tr class="separator:adf916204820072417ed73a32de1cefcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533391314665d6bf1b5575e9a9cd8552"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a533391314665d6bf1b5575e9a9cd8552">p</a> = 0</td></tr>
<tr class="separator:a533391314665d6bf1b5575e9a9cd8552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d063299e90bc953af1e0dabb27ceea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#ae6d063299e90bc953af1e0dabb27ceea">motorAngle</a> = 0</td></tr>
<tr class="separator:ae6d063299e90bc953af1e0dabb27ceea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04caa6dcdf90645ea95e5f3281d780cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a04caa6dcdf90645ea95e5f3281d780cd">Speed</a> = 5000</td></tr>
<tr class="separator:a04caa6dcdf90645ea95e5f3281d780cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a52f73797a8d06045cf5bc1ab831bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a56a52f73797a8d06045cf5bc1ab831bf">A</a> = 0</td></tr>
<tr class="separator:a56a52f73797a8d06045cf5bc1ab831bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12857102343f2f2a198414bdcc70e51b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a12857102343f2f2a198414bdcc70e51b">B</a> = 0</td></tr>
<tr class="separator:a12857102343f2f2a198414bdcc70e51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165056f7aa23bc3299b3c0e39b07eef9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a165056f7aa23bc3299b3c0e39b07eef9">maximum</a> = 0</td></tr>
<tr class="separator:a165056f7aa23bc3299b3c0e39b07eef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4f8ef6e92577b13ae2c8ffed26ac3d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a7c4f8ef6e92577b13ae2c8ffed26ac3d">maximum2</a> = 0</td></tr>
<tr class="separator:a7c4f8ef6e92577b13ae2c8ffed26ac3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f51d4573b2b2150a9327578c8fffb8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a7f51d4573b2b2150a9327578c8fffb8a">minimum</a> = 5000</td></tr>
<tr class="separator:a7f51d4573b2b2150a9327578c8fffb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e12b5193330c60dd873396cd0f8c501"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a1e12b5193330c60dd873396cd0f8c501">minimum2</a> = 5000</td></tr>
<tr class="separator:a1e12b5193330c60dd873396cd0f8c501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee244e4912223da2fb9746642c48ceeb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#aee244e4912223da2fb9746642c48ceeb">sensorMax1</a></td></tr>
<tr class="separator:aee244e4912223da2fb9746642c48ceeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74703117c114ad1264dea738dfa35b13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a74703117c114ad1264dea738dfa35b13">sensorMin1</a></td></tr>
<tr class="separator:a74703117c114ad1264dea738dfa35b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb5f75c454e5ae2561ec87bcdd3439a"><td class="memItemLeft" align="right" valign="top">TMC2209Stepper <a class="el" href="_testing_8cpp.html#a89ca3f100ff9237bda6fdf867cbd657e">tmcMotorA</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a2eb5f75c454e5ae2561ec87bcdd3439a">SERIAL_PORT</a></td></tr>
<tr class="separator:a2eb5f75c454e5ae2561ec87bcdd3439a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b4ced27e5ce9f918f76667fa8a53e5"><td class="memItemLeft" align="right" valign="top">TMC2209Stepper <a class="el" href="_testing_8cpp.html#aa3c26417a024522b28d73fbd59d64b30">tmcMotorB</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a08b4ced27e5ce9f918f76667fa8a53e5">SERIAL_PORT2</a></td></tr>
<tr class="separator:a08b4ced27e5ce9f918f76667fa8a53e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad5e76ed7529e20eb793489fe2adfb6"><td class="memItemLeft" align="right" valign="top">hw_timer_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a7ad5e76ed7529e20eb793489fe2adfb6">timer1</a> = NULL</td></tr>
<tr class="separator:a7ad5e76ed7529e20eb793489fe2adfb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3045037ba12b9984e82a9f1d513e5a5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a3045037ba12b9984e82a9f1d513e5a5f">value</a> [80]</td></tr>
<tr class="separator:a3045037ba12b9984e82a9f1d513e5a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee654054e53c6b1545612c7180f833a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#aee654054e53c6b1545612c7180f833a7">value_r</a> [80]</td></tr>
<tr class="separator:aee654054e53c6b1545612c7180f833a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498ba83c969eb5521cc89c5df5642cf2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a498ba83c969eb5521cc89c5df5642cf2">value2</a> [300]</td></tr>
<tr class="separator:a498ba83c969eb5521cc89c5df5642cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720e1d4ec0d758373d3fa0de5e2e2cef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a720e1d4ec0d758373d3fa0de5e2e2cef">value2_r</a> [300]</td></tr>
<tr class="separator:a720e1d4ec0d758373d3fa0de5e2e2cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0964910e54ee47e63c7f0e87d649fc70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a0964910e54ee47e63c7f0e87d649fc70">meanVector</a> [5]</td></tr>
<tr class="separator:a0964910e54ee47e63c7f0e87d649fc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de48aafb01b2ff92b4954b7a34b3547"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a5de48aafb01b2ff92b4954b7a34b3547">simiVector</a> [5]</td></tr>
<tr class="separator:a5de48aafb01b2ff92b4954b7a34b3547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d31951e33adf528f6d4ae210c215d9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a7d31951e33adf528f6d4ae210c215d9a">maximumVector</a> [5]</td></tr>
<tr class="separator:a7d31951e33adf528f6d4ae210c215d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae395e4515335b5d19cd00ca100d5a9a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#ae395e4515335b5d19cd00ca100d5a9a5">minimumVector</a> [5]</td></tr>
<tr class="separator:ae395e4515335b5d19cd00ca100d5a9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721393e7c0a1419e889517ee9e2cd62e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a721393e7c0a1419e889517ee9e2cd62e">meanVector2</a> [5]</td></tr>
<tr class="separator:a721393e7c0a1419e889517ee9e2cd62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3104eeba22607c45dc804fe04f59e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#aca3104eeba22607c45dc804fe04f59e5">simiVector2</a> [5]</td></tr>
<tr class="separator:aca3104eeba22607c45dc804fe04f59e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3d5e6d71d7d4f5ba9d39a268e03c18"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a7e3d5e6d71d7d4f5ba9d39a268e03c18">maximumVector2</a> [5]</td></tr>
<tr class="separator:a7e3d5e6d71d7d4f5ba9d39a268e03c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283f0255b1e5d32b7352bab7f5cb25fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a283f0255b1e5d32b7352bab7f5cb25fe">minimumVector2</a> [5]</td></tr>
<tr class="separator:a283f0255b1e5d32b7352bab7f5cb25fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f277023bb1990065444d6689d144a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a74f277023bb1990065444d6689d144a6">avoid</a> = 0</td></tr>
<tr class="separator:a74f277023bb1990065444d6689d144a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3b29db95b7ae2648962444ee76044d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a5d3b29db95b7ae2648962444ee76044d">avoid2</a> = 0</td></tr>
<tr class="separator:a5d3b29db95b7ae2648962444ee76044d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d99e23189b2be00b59a78dc861981b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a36d99e23189b2be00b59a78dc861981b">level_zero1</a></td></tr>
<tr class="separator:a36d99e23189b2be00b59a78dc861981b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d07433ea299371bb3a8835653d21ce8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a7d07433ea299371bb3a8835653d21ce8">level_zero2</a></td></tr>
<tr class="separator:a7d07433ea299371bb3a8835653d21ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ad9c7e08aca4807e3c8383ad66423c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a84ad9c7e08aca4807e3c8383ad66423c">sensorMax2</a></td></tr>
<tr class="separator:a84ad9c7e08aca4807e3c8383ad66423c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4aa5da4c352963534edaa8671a314d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a0b4aa5da4c352963534edaa8671a314d">sensorMin2</a></td></tr>
<tr class="separator:a0b4aa5da4c352963534edaa8671a314d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab761769c5786623968bcb81d7ebcc9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#aab761769c5786623968bcb81d7ebcc9c">sensorRead2</a></td></tr>
<tr class="separator:aab761769c5786623968bcb81d7ebcc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0fad4f81ef9ce5b58219f0af2f99b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#acd0fad4f81ef9ce5b58219f0af2f99b0">sensorRead1</a></td></tr>
<tr class="separator:acd0fad4f81ef9ce5b58219f0af2f99b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2244af5589ba07f28424cd8f7a1638bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#a2244af5589ba07f28424cd8f7a1638bb">sensorPole1</a></td></tr>
<tr class="separator:a2244af5589ba07f28424cd8f7a1638bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6792741c701f45224c4e91d1e945a2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#aa6792741c701f45224c4e91d1e945a2e">sensorPole2</a></td></tr>
<tr class="separator:aa6792741c701f45224c4e91d1e945a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d86d75651564daa278d5d7e62393be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_working_area_8cpp.html#aa5d86d75651564daa278d5d7e62393be">adjustIniFlag</a> = 0</td></tr>
<tr class="separator:aa5d86d75651564daa278d5d7e62393be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a631addbae85416e5e774ee3a4c3fb96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631addbae85416e5e774ee3a4c3fb96f">&#9670;&nbsp;</a></span>Check_ini()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Check_ini </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta funcion verifica si ya se han almacenado en la EEPROM las variables iniciales necesarias para en funcionamiento del sistema, lo cual solo es posible cuando se programa por primera vez la ESP32 o despues de un reset completo del sistema. </p>
<dl class="section return"><dt>Returns</dt><dd>Retorna un 1 si se determina que la EEPROM eseta vacia o un 0 en caso de que ya existan los valores almacenados. </dd></dl>

</div>
</div>
<a id="a3ff22892fe13e126f6290b4986ab47b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff22892fe13e126f6290b4986ab47b8">&#9670;&nbsp;</a></span>configTimerForMovement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void configTimerForMovement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66bc9fa321501271396177a33c87ad83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bc9fa321501271396177a33c87ad83">&#9670;&nbsp;</a></span>findingSlowSensor1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void findingSlowSensor1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta funcion continua con el proceso de calibracion una vez que el brazo 1 esta cerca del sensor hall. </p>
<p>Inicia moviendo el brazo uno 80 pasos en sentido antihorario para salir por completo del rango del sensor Comienza a tomar mediciones del sensor en cada paso que avanza en sentido horario hasta llenar el vector value[] Durante el llenado del vector tambien se determina el valor maximo entre todos los elementos del vector La grafica de los datos tiene forma gaussiana por lo cual se determina un limite del rango en cual se buscara el punto medio de la funcion, dicho rango se establecio como los valores mayores al 90% del valor maximo encontrado. Se determinan los pasos correspondientes a el limite derecho y el limite izquierdo de la funcion Se calculan los pasos necesarios para llegar al punto medio del sensor </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value[]</td><td>En este vector se alamacenan los valores obtenidos del sensor Hall. </td></tr>
    <tr><td class="paramname">limit</td><td>En esta variable se define el limite del intervalo en el cual se buscara el punto medio de los datos almacenados en el vector value. </td></tr>
    <tr><td class="paramname">steps_ini</td><td>Almacena el numero de pasos para llegar al inicio del intervalo de busqueda. </td></tr>
    <tr><td class="paramname">steps_fin</td><td>Almacena el numero de pasos para llegar al fin del intervalo de busqueda. </td></tr>
    <tr><td class="paramname">pas</td><td>Esta variable almacena los pasos necesarios para posicionar el brazo 1 al centro del sensor hall. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6ff294cb56b4ed4e7a7fbbc7b09e378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ff294cb56b4ed4e7a7fbbc7b09e378">&#9670;&nbsp;</a></span>findingSlowSensor1Negative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void findingSlowSensor1Negative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta funcion continua con el proceso de calibracion una vez que el brazo 1 esta cerca del sensor hall, esta version de la funcion contempla el polo negativo del iman DESCRIPCION GENERAL Inicia moviendo el brazo uno 80 pasos en sentido antihorario para salir por completo del rango del sensor Comienza a tomar mediciones del sensor en cada paso que avanza en sentido horario hasta llenar el vector value[] Durante el llenado del vector tambien se determina el valor maximo entre todos los elementos del vector La grafica de los datos tiene forma gaussiana por lo cual se determina un limite del rango en cual se buscara el punto medio de la funcion, dicho rango se establecio como los valores mayores al 90% del valor maximo encontrado. Se determinan los pasos correspondientes a el limite derecho y el limite izquierdo de la funcion Se calculan los pasos necesarios para llegar al punto medio del sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value[]</td><td>En este vector se alamacenan los valores obtenidos del sensor Hall. </td></tr>
    <tr><td class="paramname">limit</td><td>En esta variable se define el limite del intervalo en el cual se buscara el punto medio de los datos almacenados en el vector value. </td></tr>
    <tr><td class="paramname">steps_ini</td><td>Almacena el numero de pasos para llegar al inicio del intervalo de busqueda. </td></tr>
    <tr><td class="paramname">steps_fin</td><td>Almacena el numero de pasos para llegar al fin del intervalo de busqueda. </td></tr>
    <tr><td class="paramname">pas</td><td>Esta variable almacena los pasos necesarios para posicionar el brazo 1 al centro del sensor hall. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a798bb0d6da779177b10015a9174f4057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798bb0d6da779177b10015a9174f4057">&#9670;&nbsp;</a></span>findingSlowSensor2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void findingSlowSensor2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta funcion continua con el proceso de calibracion una vez que el brazo 2 esta cerca del sensor hall. DESCRIPCION GENERAL Inicia moviendose 100 pasos en sentido antihorario Regresa en sentido horario hasta que es detectado por el sensor Continua moviendose en sentido horario hasta completar 600 pasos, en cada paso toma la medicion del sensor y este dato se almacena en el vector value2_r[] Regresa el brazo en sentido antihorario hasta que es detectado por el sensor Continua moviendose en sentido antihorario hasta completar 600 pasos, en cada paso toma la medicion del sensor y este dato se almacena en el vector value2[] La grafica de ambos vectores es de forma gaussiana por lo cual se determina un limite del rango de busqueda en ambas funciones, dicho rango se establecio como los valores mayores al 90% del valor maximo encontrado. Se determinan los pasos correspondientes a el limite derecho y el limite izquierdo de ambas funciones y se usa el limite derecho de la funcion dos y el limite izquierdo de la funcion uno para encontrar el punto medio. Se calculan los pasos necesarios para llegar al punto medio del sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value2[]</td><td>En este vector se alamacenan los valores obtenidos del sensor Hall. </td></tr>
    <tr><td class="paramname">limit</td><td>En esta variable se define el limite del intervalo en el cual se buscara el punto medio de los datos almacenados en el vector value. </td></tr>
    <tr><td class="paramname">steps_ini</td><td>Almacena el numero de pasos para llegar al inicio del intervalo de busqueda. </td></tr>
    <tr><td class="paramname">steps_fin</td><td>Almacena el numero de pasos para llegar al fin del intervalo de busqueda. </td></tr>
    <tr><td class="paramname">pas</td><td>Esta variable almacena los pasos necesarios para posicionar el brazo 2 al centro del sensor hall. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cb69637e5b2f4d22887510391cb973d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb69637e5b2f4d22887510391cb973d">&#9670;&nbsp;</a></span>findingSlowSensor2Negative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void findingSlowSensor2Negative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta funcion continua con el proceso de calibracion una vez que el brazo 2 esta cerca del sensor hall, esta version de la funcion contempla el polo negativo del iman DESCRIPCION GENERAL Inicia moviendose 100 pasos en sentido antihorario Regresa en sentido horario hasta que es detectado por el sensor Continua moviendose en sentido horario hasta completar 600 pasos, en cada paso toma la medicion del sensor y este dato se almacena en el vector value2_r[] Regresa el brazo en sentido antihorario hasta que es detectado por el sensor Continua moviendose en sentido antihorario hasta completar 600 pasos, en cada paso toma la medicion del sensor y este dato se almacena en el vector value2[] La grafica de ambos vectores es de forma gaussiana por lo cual se determina un limite del rango de busqueda en ambas funciones, dicho rango se establecio como los valores mayores al 90% del valor maximo encontrado. Se determinan los pasos correspondientes a el limite derecho y el limite izquierdo de ambas funciones y se usa el limite derecho de la funcion dos y el limite izquierdo de la funcion uno para encontrar el punto medio. Se calculan los pasos necesarios para llegar al punto medio del sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value2[]</td><td>En este vector se alamacenan los valores obtenidos del sensor Hall. </td></tr>
    <tr><td class="paramname">limit</td><td>En esta variable se define el limite del intervalo en el cual se buscara el punto medio de los datos almacenados en el vector value. </td></tr>
    <tr><td class="paramname">steps_ini</td><td>Almacena el numero de pasos para llegar al inicio del intervalo de busqueda. </td></tr>
    <tr><td class="paramname">steps_fin</td><td>Almacena el numero de pasos para llegar al fin del intervalo de busqueda. </td></tr>
    <tr><td class="paramname">pas</td><td>Esta variable almacena los pasos necesarios para posicionar el brazo 2 al centro del sensor hall. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e55dcd0d80f36ea170e78f08d0cfd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e55dcd0d80f36ea170e78f08d0cfd6c">&#9670;&nbsp;</a></span>meanFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MeanFilter&lt;long&gt; meanFilter </td>
          <td>(</td>
          <td class="paramtype">5&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af36f626dfaa322b0676e3a69cd45d899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36f626dfaa322b0676e3a69cd45d899">&#9670;&nbsp;</a></span>meanFilter2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MeanFilter&lt;long&gt; meanFilter2 </td>
          <td>(</td>
          <td class="paramtype">40&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afda57768904b6418e308a0eba529f3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda57768904b6418e308a0eba529f3c2">&#9670;&nbsp;</a></span>meanFilter3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MeanFilter&lt;long&gt; meanFilter3 </td>
          <td>(</td>
          <td class="paramtype">10&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82191621fe6f3c65317038ee5e1b9ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82191621fe6f3c65317038ee5e1b9ef5">&#9670;&nbsp;</a></span>meanFilter4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MeanFilter&lt;long&gt; meanFilter4 </td>
          <td>(</td>
          <td class="paramtype">10&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66b0be76d13262e07d312e41bba6ab02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b0be76d13262e07d312e41bba6ab02">&#9670;&nbsp;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void move </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pasos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>motor_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Speed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta funcion perimite mover los motores de manera controlada mediante numero de pasos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pasos</td><td>Esta variable indica el numero de pasos que se desea avanzar. </td></tr>
    <tr><td class="paramname">motor_d</td><td>Indica el motor que se quiere mover, opcion 1 o 2. </td></tr>
    <tr><td class="paramname">Speed</td><td>Indica la velocidad del giro, si se disminuye el valor se aumenta la velocidad y si se aumenta este valor la velocidad disminuye . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada06ab1c4bbd307a9fea75726c8894f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada06ab1c4bbd307a9fea75726c8894f1">&#9670;&nbsp;</a></span>onTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRAM_ATTR onTimer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5ecbafdb3302781652a880f1abbfc0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ecbafdb3302781652a880f1abbfc0e">&#9670;&nbsp;</a></span>Pole1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Pole1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta funcion determina el polo del campo magnetico correspondiente al iman que interacciona con el brazo 1. DESCRIPCION GFENERAL Antes de entrar a esta funcion el brazo ya se encuentra posicionado correctamente al inicio del sensor Para determinar el polo se avanzan 100 pasos para que al retornar el movimiento el brazo termine en la mis ma posicion en la que inicio. Al retornar el sentido horario almacena el valor maximo y el valor minimo que haya obtenidode las mediciones tomadas en cada paso, este valor se obtiene como un valor absoluto respecto del nivel cero, el cual para este punto del programa ya se conoce. finalmente se compara el valor maximo absoluto obtenido y el valor minimo absoluto obtenido, si el maximo absoluto es mayor que el minimo absoluto se determina que le polo es positivo, en cambio si sucede de forma contraria se determina que el polo es negativo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect_Pole1</td><td>Se almacenan un conjunto de datos correspondientes a un barrido del brazo1 por debajo del sensor de efecto Hall. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retorna un 1 si se determina que el polo positivo y un 0 si el polo es negativo. </dd></dl>

</div>
</div>
<a id="ad469423184c79fb13fe91abe154193f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad469423184c79fb13fe91abe154193f9">&#9670;&nbsp;</a></span>Pole2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Pole2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta funcion determina el polo del campo magnetico correspondiente al iman que interacciona con el brazo 2. DESCRIPCION GFENERAL Antes de entrar a esta funcion el brazo ya se encuentra posicionado correctamente al inicio del sensor Para determinar el polo se avanzan 800 pasos para que al retornar el movimiento el brazo termine en la mis ma posicion en la que inicio. Al retornar el sentido horario almacena el valor maximo y el valor minimo que haya obtenidode las mediciones tomadas en cada paso, este valor se obtiene como un valor absoluto respecto del nivel cero, el cual para este punto del programa ya se conoce. finalmente se compara el valor maximo absoluto obtenido y el valor minimo absoluto obtenido, si el maximo absoluto es mayor que el minimo absoluto se determina que le polo es positivo, en cambio si sucede de forma contraria se determina que el polo es negativo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect_Pole2</td><td>Se almacenan un conjunto de datos correspondientes a un barrido del brazo2 por debajo del sensor de efecto Hall. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retorna un 1 si se determina que el polo positivo y un 0 si el polo es negativo. </dd></dl>

</div>
</div>
<a id="a2aeeb796a7fc547a875cd99077220f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aeeb796a7fc547a875cd99077220f83">&#9670;&nbsp;</a></span>verif_cal_negativeb1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void verif_cal_negativeb1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta funcion se utiliza entre programas para verificar que la siguiente secuencia iniciara en el punto cero. en este caso la funcion contempla solo al brazo 1 con la polaridad del iman negativa. DESCRIPCION GENERAL En la primera condicion de esta funcion se determina si el brazo se encuentra fuera del rango del sensor En caso de entrar en esta condicion inicia una busqueda con rango maximo de 200 pasos en sentido horario Si no se encuentra nada en ese rango inicia una busqueda en sentido antihorario con un rango maximo de 400 pasos Si encuentra el sensor en la primera busqueda se activa una bandera para determinar que esta posicionado del lado izquierdo del sensor posteriormente se mueve 100 pasos en sentido horario y regresa en sentido antihorario para posicionarse al inicio del sensor pero del lado derecho. Existe otro caso en el cual al iniciar la funcion el brazo ya se encuentra dentro del rango del sensor, en ese caso se mueve 100 pasos en sentido horario para garantizar que sale del sensor y posteriormente regresa en sentido antihorario hasta que es detectado por el sensor posicionandose asi del lado derecho del sensor. Finalmente cuando ya esta posicionado al inicio del lado izquierdo del sensor realiza el proceso de slow calibration para centrarse correctamente. </p>

</div>
</div>
<a id="a2348b9d8a271b99689a97fab8a460a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2348b9d8a271b99689a97fab8a460a6f">&#9670;&nbsp;</a></span>verif_cal_negativeb2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void verif_cal_negativeb2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta funcion se utiliza entre programas para verificar que la siguiente secuencia iniciara en el punto cero. en este caso la funcion contempla solo al brazo 2 con la polaridad del iman negativa. DESCRIPCION GENERAL En la primera condicion de esta funcion se determina si el brazo se encuentra fuera del rango del sensor En caso de entrar en esta condicion inicia una busqueda con rango maximo de 600 pasos en sentido antihorario Si no se encuentra nada en ese rango inicia una busqueda en sentido horario con un rango maximo de 1200 pasos Si encuentra el sensor en la primera busqueda se activa una bandera para determinar que esta posicionado del lado derecho del sensor posteriormente se mueve 600 pasos en sentido antihorario y regresa en sentido horario para posicionarse al inicio del sensor pero del lado izquierdo. Existe otro caso en el cual al iniciar la funcion el brazo ya se encuentra dentro del rango del sensor, en ese caso se mueve 600 pasos en sentido antihorario para garantizar que sale del sensor y posteriormente regresa en sentido horario hasta que es detectado por el sensor posicionandose asi del lado izquierdo del sensor. Finalmente cuando ya esta posicionado al inicio del lado izquierdo del sensor realiza el proceso de slow calibration para centrarse correctamente. </p>

</div>
</div>
<a id="a116938c1ae9fcce8a77d45b4a1f5f31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116938c1ae9fcce8a77d45b4a1f5f31b">&#9670;&nbsp;</a></span>verif_cal_positiveb1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void verif_cal_positiveb1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta funcion se utiliza entre programas para verificar que la siguiente secuencia iniciara en el punto cero. en este caso la funcion contempla solo al brazo 1 con la polaridad del iman positiva. DESCRIPCION GENERAL En la primera condicion de esta funcion se determina si el brazo se encuentra fuera del rango del sensor En caso de entrar en esta condicion inicia una busqueda con rango maximo de 200 pasos en sentido horario Si no se encuentra nada en ese rango inicia una busqueda en sentido antihorario con un rango maximo de 400 pasos Si encuentra el sensor en la primera busqueda se activa una bandera para determinar que esta posicionado del lado izquierdo del sensor posteriormente se mueve 100 pasos en sentido horario y regresa en sentido antihorario para posicionarse al inicio del sensor pero del lado derecho. Existe otro caso en el cual al iniciar la funcion el brazo ya se encuentra dentro del rango del sensor, en ese caso se mueve 100 pasos en sentido horario para garantizar que sale del sensor y posteriormente regresa en sentido antihorario hasta que es detectado por el sensor posicionandose asi del lado derecho del sensor. Finalmente cuando ya esta posicionado al inicio del lado derecho del sensor realiza el proceso de slow calibration para centrarse correctamente. </p>

</div>
</div>
<a id="a6974d83fb1a8c1abd074a6003a966b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6974d83fb1a8c1abd074a6003a966b17">&#9670;&nbsp;</a></span>verif_cal_positiveb2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void verif_cal_positiveb2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta funcion se utiliza entre programas para verificar que la siguiente secuencia iniciara en el punto cero. en este caso la funcion contempla solo al brazo 2 con la polaridad del iman positiva. DESCRIPCION GENERAL En la primera condicion de esta funcion se determina si el brazo se encuentra fuera del rango del sensor En caso de entrar en esta condicion inicia una busqueda con rango maximo de 600 pasos en sentido antihorario Si no se encuentra nada en ese rango inicia una busqueda en sentido horario con un rango maximo de 1200 pasos Si encuentra el sensor en la primera busqueda se activa una bandera para determinar que esta posicionado del lado derecho del sensor posteriormente se mueve 600 pasos en sentido antihorario y regresa en sentido horario para posicionarse al inicio del sensor pero del lado izquierdo. Existe otro caso en el cual al iniciar la funcion el brazo ya se encuentra dentro del rango del sensor, en ese caso se mueve 600 pasos en sentido antihorario para garantizar que sale del sensor y posteriormente regresa en sentido horario hasta que es detectado por el sensor posicionandose asi del lado izquierdo del sensor. Finalmente cuando ya esta posicionado al inicio del lado izquierdo del sensor realiza el proceso de slow calibration para centrarse correctamente. </p>

</div>
</div>
<a id="a84621fca61c95f2748a53815d2a856fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84621fca61c95f2748a53815d2a856fb">&#9670;&nbsp;</a></span>zero_Hall1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zero_Hall1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta funcion determina el nivel de referencia a partir del cual se considera la deteccion de campo magnetico. DESCRIPCION GENERAL Esta funcion inicia moviendo el brazo en sentido antihorario usando la funcion configTimerForMovement y sensando el DIAG_PIN en caso de que el brazo colisione, si colisiona el brazo 1 regresa 300 pasos y el brazo 2 baja a 90 grados para evitar la colision. Si el brazo logra finalizar el primer movimiento sin colisionar regresa 800 pasos e inicia el algoritmo para determinar el nivel cero del sensor. Se toman 5 muestras en angulos distintos, la primera muestra se toma desde donde quedo posicionado el brazo, posteriormente se mueve 10 grados en sentido horario para tomar la segunda muestra, se mueve 10 grados en sentido horario para la tercera medicion, regresa 30 grados en sentido antihorario para la cuarta medicion y avanza 10 grados mas para tomar la quita medicion. En cada una de las 5 muestras se toman 5 mediciones filtradas de las cuales se obtienen el valor maximo, el valor minimo, el valor promedio y un valor al que se le determino como valor similitud ya que es comparado con cada promedio de las 5 muestras tomadas a diferentes algulos y se almacena el contador de cuantos valores son similares al de la muestra analizada. Finalmente se determina que si 3 muestras o mas son similares se ha hallado el valor cero del sensor el cual se almacena en una variable global y se retorna un 1 para indicar que no es necesario repetir el procedimiento. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level_zero1</td><td>esta variable global almacena el nivel de referencia para el sensor Hall 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retorna un 1 si el calculo del nivel de referencia se obtuvo correctamente, en caso contrario retorna un 0 para repetir de proceso de busqueda del nivel de referencia. </dd></dl>

</div>
</div>
<a id="a83423ebb090b867ca0e0680ba5ee33ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83423ebb090b867ca0e0680ba5ee33ef">&#9670;&nbsp;</a></span>zero_Hall2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zero_Hall2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta funcion determina el nivel de referencia a partir del cual se considera la deteccion de campo magnetico. DESCRIPCION GENERAL Esta funcion inicia moviendo el brazo en sentido antihorario usando la funcion configTimerForMovement y sensando el DIAG_PIN en caso de que el brazo colisione, si colisiona el brazo 1 regresa 300 pasos y el brazo 2 baja a 90 grados para evitar la colision. Si el brazo logra finalizar el primer movimiento sin colisionar regresa 800 pasos e inicia el algoritmo para determinar el nivel cero del sensor. Se toman 5 muestras en angulos distintos, la primera muestra se toma desde donde quedo posicionado el brazo, posteriormente se mueve 10 grados en sentido horario para tomar la segunda muestra, se mueve 10 grados en sentido horario para la tercera medicion, regresa 30 grados en sentido antihorario para la cuarta medicion y avanza 10 grados mas para tomar la quita medicion. En cada una de las 5 muestras se toman 5 mediciones filtradas de las cuales se obtienen el valor maximo, el valor minimo, el valor promedio y un valor al que se le determino como valor similitud ya que es comparado con cada promedio de las 5 muestras tomadas a diferentes algulos y se almacena el contador de cuantos valores son similares al de la muestra analizada. Finalmente se determina que si 3 muestras o mas son similares se ha hallado el valor cero del sensor el cual se almacena en una variable global y se retorna un 1 para indicar que no es necesario repetir el procedimiento. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level_zero2</td><td>esta variable global almacena el nivel de referencia para el sensor Hall 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retorna un 1 si el calculo del nivel de referencia se obtuvo correctamente, en caso contrario retorna un 0 para repetir de proceso de busqueda del nivel de referencia. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a56a52f73797a8d06045cf5bc1ab831bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a52f73797a8d06045cf5bc1ab831bf">&#9670;&nbsp;</a></span>A</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int A = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5d86d75651564daa278d5d7e62393be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d86d75651564daa278d5d7e62393be">&#9670;&nbsp;</a></span>adjustIniFlag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int adjustIniFlag = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74f277023bb1990065444d6689d144a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f277023bb1990065444d6689d144a6">&#9670;&nbsp;</a></span>avoid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avoid = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d3b29db95b7ae2648962444ee76044d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3b29db95b7ae2648962444ee76044d">&#9670;&nbsp;</a></span>avoid2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avoid2 = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12857102343f2f2a198414bdcc70e51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12857102343f2f2a198414bdcc70e51b">&#9670;&nbsp;</a></span>B</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int B = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf916204820072417ed73a32de1cefcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf916204820072417ed73a32de1cefcf">&#9670;&nbsp;</a></span>flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int flag = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae925ac80771845fdf6ceecea82d43372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae925ac80771845fdf6ceecea82d43372">&#9670;&nbsp;</a></span>H</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte H</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff17ae1975ccaad350d7ce45584b8765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff17ae1975ccaad350d7ce45584b8765">&#9670;&nbsp;</a></span>L</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte L</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a36d99e23189b2be00b59a78dc861981b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d99e23189b2be00b59a78dc861981b">&#9670;&nbsp;</a></span>level_zero1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int level_zero1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d07433ea299371bb3a8835653d21ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d07433ea299371bb3a8835653d21ce8">&#9670;&nbsp;</a></span>level_zero2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int level_zero2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a165056f7aa23bc3299b3c0e39b07eef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a165056f7aa23bc3299b3c0e39b07eef9">&#9670;&nbsp;</a></span>maximum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int maximum = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c4f8ef6e92577b13ae2c8ffed26ac3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4f8ef6e92577b13ae2c8ffed26ac3d">&#9670;&nbsp;</a></span>maximum2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int maximum2 = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d31951e33adf528f6d4ae210c215d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d31951e33adf528f6d4ae210c215d9a">&#9670;&nbsp;</a></span>maximumVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int maximumVector[5]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e3d5e6d71d7d4f5ba9d39a268e03c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3d5e6d71d7d4f5ba9d39a268e03c18">&#9670;&nbsp;</a></span>maximumVector2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int maximumVector2[5]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0964910e54ee47e63c7f0e87d649fc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0964910e54ee47e63c7f0e87d649fc70">&#9670;&nbsp;</a></span>meanVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int meanVector[5]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a721393e7c0a1419e889517ee9e2cd62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721393e7c0a1419e889517ee9e2cd62e">&#9670;&nbsp;</a></span>meanVector2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int meanVector2[5]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fa11698cbe6b645e4e5763adde2b20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa11698cbe6b645e4e5763adde2b20e">&#9670;&nbsp;</a></span>MICROSTEPPING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MICROSTEPPING = String(String(<a class="el" href="main_8cpp.html#a19f09ab8a4c025b852ae0ac4f32821cd">dataS</a>[1]) + String(<a class="el" href="main_8cpp.html#a19f09ab8a4c025b852ae0ac4f32821cd">dataS</a>[2])).toFloat()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f51d4573b2b2150a9327578c8fffb8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f51d4573b2b2150a9327578c8fffb8a">&#9670;&nbsp;</a></span>minimum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int minimum = 5000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e12b5193330c60dd873396cd0f8c501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e12b5193330c60dd873396cd0f8c501">&#9670;&nbsp;</a></span>minimum2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int minimum2 = 5000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae395e4515335b5d19cd00ca100d5a9a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae395e4515335b5d19cd00ca100d5a9a5">&#9670;&nbsp;</a></span>minimumVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int minimumVector[5]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a283f0255b1e5d32b7352bab7f5cb25fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283f0255b1e5d32b7352bab7f5cb25fe">&#9670;&nbsp;</a></span>minimumVector2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int minimumVector2[5]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6d063299e90bc953af1e0dabb27ceea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d063299e90bc953af1e0dabb27ceea">&#9670;&nbsp;</a></span>motorAngle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int motorAngle = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a533391314665d6bf1b5575e9a9cd8552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533391314665d6bf1b5575e9a9cd8552">&#9670;&nbsp;</a></span>p</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int p = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee244e4912223da2fb9746642c48ceeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee244e4912223da2fb9746642c48ceeb">&#9670;&nbsp;</a></span>sensorMax1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sensorMax1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84ad9c7e08aca4807e3c8383ad66423c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ad9c7e08aca4807e3c8383ad66423c">&#9670;&nbsp;</a></span>sensorMax2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sensorMax2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74703117c114ad1264dea738dfa35b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74703117c114ad1264dea738dfa35b13">&#9670;&nbsp;</a></span>sensorMin1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sensorMin1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b4aa5da4c352963534edaa8671a314d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4aa5da4c352963534edaa8671a314d">&#9670;&nbsp;</a></span>sensorMin2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sensorMin2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2244af5589ba07f28424cd8f7a1638bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2244af5589ba07f28424cd8f7a1638bb">&#9670;&nbsp;</a></span>sensorPole1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sensorPole1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6792741c701f45224c4e91d1e945a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6792741c701f45224c4e91d1e945a2e">&#9670;&nbsp;</a></span>sensorPole2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sensorPole2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd0fad4f81ef9ce5b58219f0af2f99b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0fad4f81ef9ce5b58219f0af2f99b0">&#9670;&nbsp;</a></span>sensorRead1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sensorRead1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab761769c5786623968bcb81d7ebcc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab761769c5786623968bcb81d7ebcc9c">&#9670;&nbsp;</a></span>sensorRead2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sensorRead2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2eb5f75c454e5ae2561ec87bcdd3439a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb5f75c454e5ae2561ec87bcdd3439a">&#9670;&nbsp;</a></span>SERIAL_PORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMC2209Stepper <a class="el" href="_testing_8cpp.html#a89ca3f100ff9237bda6fdf867cbd657e">tmcMotorA</a>&amp; SERIAL_PORT</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a08b4ced27e5ce9f918f76667fa8a53e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b4ced27e5ce9f918f76667fa8a53e5">&#9670;&nbsp;</a></span>SERIAL_PORT2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMC2209Stepper <a class="el" href="_testing_8cpp.html#aa3c26417a024522b28d73fbd59d64b30">tmcMotorB</a>&amp; SERIAL_PORT2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5de48aafb01b2ff92b4954b7a34b3547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de48aafb01b2ff92b4954b7a34b3547">&#9670;&nbsp;</a></span>simiVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int simiVector[5]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca3104eeba22607c45dc804fe04f59e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3104eeba22607c45dc804fe04f59e5">&#9670;&nbsp;</a></span>simiVector2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int simiVector2[5]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04caa6dcdf90645ea95e5f3281d780cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04caa6dcdf90645ea95e5f3281d780cd">&#9670;&nbsp;</a></span>Speed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Speed = 5000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ad5e76ed7529e20eb793489fe2adfb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad5e76ed7529e20eb793489fe2adfb6">&#9670;&nbsp;</a></span>timer1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hw_timer_t* timer1 = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3045037ba12b9984e82a9f1d513e5a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3045037ba12b9984e82a9f1d513e5a5f">&#9670;&nbsp;</a></span>value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int value[80]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a498ba83c969eb5521cc89c5df5642cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498ba83c969eb5521cc89c5df5642cf2">&#9670;&nbsp;</a></span>value2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int value2[300]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a720e1d4ec0d758373d3fa0de5e2e2cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720e1d4ec0d758373d3fa0de5e2e2cef">&#9670;&nbsp;</a></span>value2_r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int value2_r[300]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee654054e53c6b1545612c7180f833a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee654054e53c6b1545612c7180f833a7">&#9670;&nbsp;</a></span>value_r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int value_r[80]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_f82768eb38b81461705decc7ae5a77f4.html">firmwareSandsara</a></li><li class="navelem"><a class="el" href="dir_3bf9cc3430cf8e6922b84fc54ffbdacc.html">src</a></li><li class="navelem"><a class="el" href="_working_area_8cpp.html">WorkingArea.cpp</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
